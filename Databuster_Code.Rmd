---
title: "databusters_"
author: "YH"
date: "2025-02-07"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(readr)
library(readxl)
library(stringr)
library(lubridate)
library(tidyverse)
library(dplyr)
library(dynlm)
library(vars)
library(tseries)
library(forecast)
```


## Exploring the data

```{r explore, echo=FALSE}
vars = read_csv("Variable Description.csv", show_col_types = FALSE)
df = read_csv("Quarterly Data.csv", show_col_types = FALSE)
```


Selecting indicators that we want to use only
```{r}
df_select <- df[-(1:2),] 
df_select <- df_select %>% 
  dplyr:: select(sasdate, GDPC1, UNRATE, PCECC96) %>%
  mutate(sasdate = dmy(sasdate))

```


Load and prepare data
```{r}
start_year <- year(min(df_select$sasdate, na.rm = TRUE)) 
start_quarter <- quarter(min(df_select$sasdate, na.rm = TRUE))
ts_data <- ts(df_select[, c("GDPC1", "UNRATE", "PCECC96")], start = c(start_year,start_quarter), frequency = 4)
```


Check for stationary 
-if p-value < 0.05, the series is staionary
-if not, apply differencing
```{r}
adf.test(ts_data[,"GDPC1"])          #not stationary
adf.test(ts_data[,"UNRATE"])         #stationary
adf.test(ts_data[,"PCECC96"])        #not stationary

# apply differencing on GDP growth (GDPC1) and consumer spending (PCECC96)
ts_data <- diff(ts_data)

```


Determine the Optimal lag Order
Based on the graph, we could try to fit an AR model using p = 2 or p = 3
```{r}
acf(ts_data)   # Identifies potential MA terms
pacf(ts_data)  # Identifies AR terms


VARselect(ts_data, lag.max = 10, type = "const")$selection

```

Fitting the ADL model with different p 
```{r}
# Fit different ADL models with varying lag lengths
#p = 3
model_adl_3 <- dynlm(GDPC1 ~ L(GDPC1, 1) + L(GDPC1, 2) + L(GDPC1, 3) + 
                      L(UNRATE, 1) + L(PCECC96, 1), data = ts_data)
#p = 4
model_adl_4 <- dynlm(GDPC1 ~ L(GDPC1, 1) + L(GDPC1, 2) + L(GDPC1, 3) + L(GDPC1, 4) +
                      L(UNRATE, 1) + L(PCECC96, 1), data = ts_data)
#p = 5
model_adl_5 <- dynlm(GDPC1 ~ L(GDPC1, 1) + L(GDPC1, 2) + L(GDPC1, 3) + L(GDPC1, 4) + L(GDPC1, 5) +
                      L(UNRATE, 1) + L(PCECC96, 1), data = ts_data)
#p = 7
model_adl_7 <- dynlm(GDPC1 ~ L(GDPC1, 1) + L(GDPC1, 2) + L(GDPC1, 3) + L(GDPC1, 4) + L(GDPC1, 5) + L(GDPC1, 6) + L(GDPC1, 7) + L(UNRATE, 1) + L(PCECC96, 1), data = ts_data)

# p = 10
model_adl_10 <- dynlm(GDPC1 ~ L(GDPC1, 1) + L(GDPC1, 2) + L(GDPC1, 3) + L(GDPC1, 4) + L(GDPC1, 5) + L(GDPC1, 6) + L(GDPC1, 7) + L(GDPC1, 8) +L(GDPC1, 9) +L(GDPC1, 10) + L(UNRATE, 1) + L(UNRATE, 2), data = ts_data)



# Compare models
AIC(model_adl_3, model_adl_4, model_adl_5, model_adl_7)
BIC(model_adl_3, model_adl_4, model_adl_5, model_adl_7)

# p = 7 gives the lowest AIC and BIC

```

Method 2?
```{r}
p_values <- 1:10

# Create an empty list to store AIC values
aic_values <- numeric(length(p_values))

# Loop over different values of p
for (p in p_values) {
  # Construct the formula dynamically
  formula_str <- paste0("GDPC1 ~ ", 
                        paste0("L(GDPC1, ", 1:p, ")", collapse = " + "))  
  
  # Fit the model
  model <- dynlm(as.formula(formula_str), data = ts_data)
  
  # Store AIC value
  aic_values[p] <- AIC(model)
}

# Create a data frame to display AIC values
aic_results <- data.frame(p = p_values, AIC = aic_values)

# Print the AIC values for comparison
print(aic_results)


```

Choosing UNRATE
number of lags: 2
```{r}
# Define the range of lags for UNRATE
unrate_lags <- 1:10  

# Create an empty list to store AIC values
aic_values <- numeric(length(unrate_lags))

# Loop over different lag values for UNRATE
for (lag in unrate_lags) {
  # Construct the formula dynamically
  formula_str <- paste0("GDPC1 ~ ", 
                        paste0("L(GDPC1, ", 1:10, ")", collapse = " + "),  # Fixed lags for GDPC1
                        " + ", 
                        paste0("L(UNRATE, ", 1:lag, ")", collapse = " + "))  # Varying lags for UNRATE
  model <- dynlm(as.formula(formula_str), data = ts_data)
  aic_values[lag] <- AIC(model)
}

# Create a data frame to display AIC values
aic_results <- data.frame(UNRATE_Lags = unrate_lags, AIC = aic_values)

# Print the AIC values for comparison
print(aic_results) 

#Plot a graph to see which lag will give the lowest AIC
plot(aic_results$UNRATE_Lags, aic_results$AIC, type="b", pch=19, col="blue",
     xlab="Number of Lags for UNRATE", ylab="AIC", main="AIC for Different UNRATE Lags")


```

Choosing PCECC96
number of lags: 5
```{r}
# Define the range of lags for PCECC96
pcecc96_lags <- 1:10  

# Create an empty list to store AIC values
aic_values <- numeric(length(pcecc96_lags))

# Loop over different lag values for PCECC96
for (lag in pcecc96_lags) {
  # Construct the formula dynamically
  formula_str <- paste0("GDPC1 ~ ", 
                        paste0("L(GDPC1, ", 1:10, ")", collapse = " + "),  # Fixed lags for GDPC1
                        " + ", 
                        paste0("L(UNRATE, ", 1:2, ")", collapse = " + "),  # Fixed lags for UNRATE
                        " + ", 
                        paste0("L(PCECC96, ", 1:lag, ")", collapse = " + "))  # Varying lags for PCECC96
  model <- dynlm(as.formula(formula_str), data = ts_data)
  aic_values[lag] <- AIC(model)
}

# Create a data frame to display AIC values
aic_results <- data.frame(PCECC96_Lags = pcecc96_lags, AIC = aic_values)

# Print the AIC values for comparison
print(aic_results)


plot(aic_results$PCECC96_Lags, aic_results$AIC, type="b", pch=19, col="blue",
     xlab="Number of Lags for PCECC96", ylab="AIC", main="AIC for Different PCECC96 Lags")

```

Final model
```{r}
final_model <- dynlm(GDPC1 ~ L(GDPC1, 1) + L(GDPC1, 2) + L(GDPC1, 3) + L(GDPC1, 4) + L(GDPC1, 5) + L(GDPC1, 6) + L(GDPC1, 7) + L(GDPC1, 8) +L(GDPC1, 9) +L(GDPC1, 10) + L(UNRATE, 1) + L(UNRATE, 2) + L(PCECC96, 1)+ L(PCECC96, 2)+ L(PCECC96, 3)+ L(PCECC96, 4)+ L(PCECC96, 5), data = ts_data)
```




```{r}
forecast_values <- predict(final_model, n.ahead = 4)  # Forecast next 4 periods
print(forecast_values)

```




