---
title: "databusters_"
author: "YH"
date: "2025-02-07"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(readr)
library(readxl)
library(stringr)
library(lubridate)
library(tidyverse)
library(dplyr)
library(dynlm)
library(vars)
library(tseries)
library(forecast)
library(ggcorrplot)
library(rlang)
```


# Exploring the data

```{r explore, echo=FALSE}
vars = read_csv("Variable Description.csv", show_col_types = FALSE)
df = read_csv("Quarterly Data.csv", show_col_types = FALSE)
```


Selecting indicators that we want to use only
```{r}
df_select <- df[-(1:2),] 
df_select <- df_select %>% 
  dplyr:: select(sasdate, GDPC1, UNRATE, PCECC96) %>%
  mutate(sasdate = dmy(sasdate))

```


### Load and prepare data
```{r}
start_year <- year(min(df_select$sasdate, na.rm = TRUE)) 
start_quarter <- quarter(min(df_select$sasdate, na.rm = TRUE))
ts_data <- ts(df_select[, c("GDPC1", "UNRATE", "PCECC96")], start = c(start_year,start_quarter), frequency = 4)
```


### Data Exploration 
```{r}
ggplot(df_select, aes(x = sasdate, y = GDPC1)) +
  geom_line(color = "blue", size = 1) +
  geom_point(color = "red", size = 2) + 
  labs(title = "GDP against time", x = "Date", y = "GDPC1") +
  theme_minimal() + 
  scale_x_date(limits = c(as.Date("1980-01-03"), as.Date("2024-01-09"))) 

```




### Check for stationary 
-if p-value < 0.05, the series is staionary
-if not, apply differencing
```{r}
adf.test(ts_data[,"GDPC1"])          #not stationary
adf.test(ts_data[,"UNRATE"])         #stationary
adf.test(ts_data[,"PCECC96"])        #not stationary

# apply differencing on GDP growth (GDPC1) and consumer spending (PCECC96)
ts_data <- diff(ts_data)

```
### Splitting Train/Test Sets 
```{r}
train_data <- window(ts_data, start=1959, end=2012) # Use all but last 4 points for training
test_data <-  window(ts_data, start=2012) # Last 4 points as test set
test_data <- test_data[-1,]
```


### Determining optimal lag lengths
Determining p
```{r}
p_values <- 1:10

# Create an empty list to store AIC values
aic_values <- numeric(length(p_values))

# Loop over different values of p
for (p in p_values) {
  # Construct the formula dynamically
  formula_str <- paste0("GDPC1 ~ ", 
                        paste0("L(GDPC1, ", 1:p, ")", collapse = " + "))  
  model <- dynlm(as.formula(formula_str), data = train_data)
  aic_values[p] <- AIC(model)
}

# Create a data frame to display AIC values
aic_results <- data.frame(p = p_values, AIC = aic_values)

# Print AIC values for comparison
print(aic_results)

#Plot a graph to see which lag will give the lowest AIC
plot(aic_results$p, aic_results$AIC, type="b", pch=19, col="blue",
     xlab="Number of Lags for GDPC1", ylab="AIC", main="AIC for Different GDPC1 Lags")

```


Choosing UNRATE
number of lags: 2
```{r}
# Define the range of lags for UNRATE
unrate_lags <- 1:10  

# Create an empty list to store AIC values
aic_values2 <- numeric(length(unrate_lags))

# Loop over different lag values for UNRATE
for (lag in unrate_lags) {
  # Construct the formula dynamically
  formula_str <- paste0("GDPC1 ~ ", 
                        paste0("L(GDPC1, ", 1:10, ")", collapse = " + "),  # Fixed lags for GDPC1
                        " + ", 
                        paste0("L(UNRATE, ", 1:lag, ")", collapse = " + "))  # Varying lags for UNRATE
  model <- dynlm(as.formula(formula_str), data = train_data)
  aic_values2[lag] <- AIC(model)
}

# Create a data frame to display AIC values
aic_results2 <- data.frame(UNRATE_Lags = unrate_lags, AIC = aic_values2)

# Print the AIC values for comparison
print(aic_results2) 

#Plot a graph to see which lag will give the lowest AIC
plot(aic_results2$UNRATE_Lags, aic_results2$AIC, type="b", pch=19, col="blue",
     xlab="Number of Lags for UNRATE", ylab="AIC", main="AIC for Different UNRATE Lags")

```

Choosing PCECC96
number of lags: 3
```{r}
# Define the range of lags for PCECC96
pcecc96_lags <- 1:10  

# Create an empty list to store AIC values
aic_values3 <- numeric(length(pcecc96_lags))

# Loop over different lag values for PCECC96
for (lag in pcecc96_lags) {
  # Construct the formula dynamically
  formula_str <- paste0("GDPC1 ~ ", 
                        paste0("L(GDPC1, ", 1:10, ")", collapse = " + "),  # Fixed lags for GDPC1
                        " + ", 
                        paste0("L(UNRATE, ", 1:2, ")", collapse = " + "),  # Fixed lags for UNRATE
                        " + ", 
                        paste0("L(PCECC96, ", 1:lag, ")", collapse = " + "))  # Varying lags for PCECC96
  model <- dynlm(as.formula(formula_str), data = train_data)
  aic_values3[lag] <- AIC(model)
}

# Create a data frame to display AIC values
aic_results3 <- data.frame(PCECC96_Lags = pcecc96_lags, AIC = aic_values3)

# Print the AIC values for comparison
print(aic_results)

#Plot a graph to see which lag will give the lowest AIC
plot(aic_results3$PCECC96_Lags, aic_results3$AIC, type="b", pch=19, col="blue",
     xlab="Number of Lags for PCECC96", ylab="AIC", main="AIC for Different PCECC96 Lags")

```


### Final model
```{r}
final_model <- dynlm(GDPC1 ~ L(GDPC1, 1) + L(GDPC1, 2) + L(GDPC1, 3) + L(GDPC1, 4) + L(GDPC1, 5) + L(GDPC1, 6) + L(GDPC1, 7) + L(GDPC1, 8) +L(GDPC1, 9) +L(GDPC1, 10) + L(UNRATE, 1) + L(UNRATE, 2) + L(PCECC96, 1)+ L(PCECC96, 2)+ L(PCECC96, 3), data = train_data)
```


Using arima to predict values for UNRATE
```{r}
data <- ts_data[,2]
model <- arima(data, order= c(1, 0,0))  # Simpler AR(1) model
summary(model)

value_UNRATE <- forecast(model, h=4)
print(value_UNRATE)
```


Using arima to predict values for PCECC96
```{r}
data2 <- ts_data[,3]
model2 <- auto.arima(data2)  # Simpler AR(1) model
summary(model2)

value_PEC <- forecast(model2, h=4)
print(value_PEC)

```


### Extracting the point forecasts values
```{r}
point_forecasts_pec <- value_PEC$mean
point_forecasts_values <- as.numeric(point_forecasts_pec)

point_forecasts_UNRATE <- value_UNRATE$mean
point_forecasts_values_ <- as.numeric(point_forecasts_UNRATE) 

# Create a new data frame and add the new point forecast values to ts_data
new_rows <- cbind(c(0,0,0,0),point_forecasts_values_, point_forecasts_values)

new_data_frame <- rbind(ts_data, new_rows)
```


# Forecasting
```{r}
#Forecast for 4 periods
forecast_values <- predict(final_model, n.ahead = 4, newdata=data.frame(new_data_frame))
print(forecast_values)

```


## Evaluating Our Model 
```{r}
train_model_1 <- dynlm(train_data[,1] ~ L(train_data[,1], 1) + L(train_data[,1], 2) + L(train_data[,1], 3) + L(train_data[,1], 4) + L(train_data[,1], 5) + L(train_data[,1], 6) + L(train_data[,1], 7) + L(train_data[,1], 8) +L(train_data[,1], 9) +L(train_data[,1], 10) + L(train_data[,2], 1) + L(train_data[,2], 2) + L(train_data[,3], 1)+ L(train_data[,3], 2)+ L(train_data[,3], 3)+ L(train_data[,3], 4)+ L(train_data[,3], 5), data = train_data)
```

```{r}
forecast_values <- predict(train_model_1, newdata = data.frame(test_data))
accuracy(forecast_values, test_data[,1])
```
```{r}

```


