---
title: "databusters_"
author: "YH"
date: "2025-02-07"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(readr)
library(tidyverse)
library(tseries)
```

```{r}
library(readr)
library(readxl)
library(stringr)
library(lubridate)
library(tidyverse)
library(dynlm)
library(vars)
library(tseries)
library(forecast)
```


## Exploring the data

```{r explore, echo=FALSE}
<<<<<<< HEAD
vars = read.csv("Variable Description.csv")
df_monthly = read.csv("Monthly Data.csv")
df_quarterly = read.csv("Quarterly Data.csv")

# cleaning df
df = df_quarterly %>%
  slice(-c(1,2)) %>%
  mutate(sasdate=as.Date(dmy(sasdate))) %>% 
  mutate(y_ts = ts(df$GDPC1, start = c(1959, 3), frequency = 4), .after=GDPC1) #make gdp time series object

# stationary test
adf_test <- adf.test(y_ts)
print(adf_test)

# stationarity transformation (first difference)
y_ts_diff <- diff(y_ts)
adf_test_diff <- adf.test(y_ts_diff)
print(adf_test_diff)

max_p <- 10  # You can adjust this

# finding aic/bic for diff ps
# storage for AIC and BIC
aic_values <- numeric(max_p)
bic_values <- numeric(max_p)

# Loop through different values of p
for (p in 1:max_p) {
  model <- arima(y_ts_diff, order = c(p, 0, 0))  # AR(p) model
  aic_values[p] <- AIC(model)  # Store AIC at index p
  bic_values[p] <- BIC(model)  # Store BIC at index p
}

# Find the best p based on AIC and BIC
best_p_aic <- which.min(aic_values)
print(paste("Best p based on AIC:", best_p_aic))
best_p_bic <- which.min(bic_values)
print(paste("Best p based on BIC:", best_p_bic))
=======
vars = read_csv("../data/Variable Description.csv", show_col_types = FALSE)
df = read_csv("../data/Quarterly Data.csv", show_col_types = FALSE)
```
>>>>>>> 65ee6ce999d0d80493b6523ade454f85c1378e6c

Selecting indicators that we want to use only
```{r}
df_select <- df[-(1:2),] 
df_select <- df_select %>% 
  select(sasdate, GDPC1, UNRATE, PCECC96) %>%
  mutate(sasdate = dmy(sasdate))

```


Load and prepare data
```{r}
start_year <- year(min(df_select$sasdate, na.rm = TRUE)) 
start_quarter <- quarter(min(df_select$sasdate, na.rm = TRUE))
ts_data <- ts(df_select[, c("GDPC1", "UNRATE", "PCECC96")], start = c(start_year,start_quarter), frequency = 4)
```


Check for stationary 
-if p-value < 0.05, the series is staionary
-if not, apply differencing
```{r}
adf.test(ts_data[,"GDPC1"])          #not stationary
adf.test(ts_data[,"UNRATE"])         #stationary
adf.test(ts_data[,"PCECC96"])        #not stationary

# apply differencing on GDP growth (GDPC1) and consumer spending (PCECC96)
ts_data <- diff(ts_data)

```


Determine the Optimal lag Order
Based on the graph, we could try to fit an AR model using p = 2 or p = 3
```{r}
acf(ts_data)   # Identifies potential MA terms
pacf(ts_data)  # Identifies AR terms

#i got this from chatgpt
VARselect(ts_data, lag.max = 10, type = "const")$selection

```

Fitting the VAR model with no moving average terms 
```{r}
# p = 2
var_model <- VAR(ts_data, p = 2, type = "const") 
summary(var_model)

# p = 3
var_model2 <- VAR(ts_data, p = 3, type = "const") 
summary(var_model2)

# p = 4
var_model3 <- VAR(ts_data, p = 4, type = "const") 
summary(var_model3)

# p = 5
var_model4 <- VAR(ts_data, p = 5, type = "const") 
summary(var_model4)

```


```{r}
forecast_values <- predict(var_model, n.ahead = 4)  # Forecast next 4 periods
plot(forecast_values)
```




