---
title: "databusters_"
author: "YH"
date: "2025-02-07"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(readr)
library(readxl)
library(stringr)
library(lubridate)
library(tidyverse)
library(dplyr)
library(dynlm)
library(vars)
library(tseries)
library(forecast)
library(rlang)
```


# Exploring the data

```{r explore, echo=FALSE}
vars = read_csv("Variable Description.csv", show_col_types = FALSE)
df = read_csv("Quarterly Data.csv", show_col_types = FALSE)
```


Selecting indicators that we want to use only
```{r}
df_select <- df[-(1:2),] 
df_select <- df_select %>% 
  dplyr:: select(sasdate, GDPC1, UNRATE, PCECC96) %>%
  mutate(sasdate = dmy(sasdate))

```


### Load and prepare data
```{r}
start_year <- year(min(df_select$sasdate, na.rm = TRUE)) 
start_quarter <- quarter(min(df_select$sasdate, na.rm = TRUE))
ts_data <- ts(df_select[, c("GDPC1", "UNRATE", "PCECC96")], start = c(start_year,start_quarter), frequency = 4)
```


### Check for stationary 
-if p-value < 0.05, the series is staionary
-if not, apply differencing
```{r}
adf.test(ts_data[,"GDPC1"])          #not stationary
adf.test(ts_data[,"UNRATE"])         #stationary
adf.test(ts_data[,"PCECC96"])        #not stationary

# apply differencing on GDP growth (GDPC1) and consumer spending (PCECC96)
ts_data <- diff(ts_data)

```


### Determining optimal lag lengths
Determining p
```{r}
p_values <- 1:10

# Create an empty list to store AIC values
aic_values <- numeric(length(p_values))

# Loop over different values of p
for (p in p_values) {
  # Construct the formula dynamically
  formula_str <- paste0("GDPC1 ~ ", 
                        paste0("L(GDPC1, ", 1:p, ")", collapse = " + "))  
  model <- dynlm(as.formula(formula_str), data = ts_data)
  aic_values[p] <- AIC(model)
}

# Create a data frame to display AIC values
aic_results <- data.frame(p = p_values, AIC = aic_values)

# Print AIC values for comparison
print(aic_results)

#Plot a graph to see which lag will give the lowest AIC
plot(aic_results$p, aic_results$AIC, type="b", pch=19, col="blue",
     xlab="Number of Lags for GDPC1", ylab="AIC", main="AIC for Different GDPC1 Lags")

```


Choosing UNRATE
number of lags: 2
```{r}
# Define the range of lags for UNRATE
unrate_lags <- 1:10  

# Create an empty list to store AIC values
aic_values2 <- numeric(length(unrate_lags))

# Loop over different lag values for UNRATE
for (lag in unrate_lags) {
  # Construct the formula dynamically
  formula_str <- paste0("GDPC1 ~ ", 
                        paste0("L(GDPC1, ", 1:10, ")", collapse = " + "),  # Fixed lags for GDPC1
                        " + ", 
                        paste0("L(UNRATE, ", 1:lag, ")", collapse = " + "))  # Varying lags for UNRATE
  model <- dynlm(as.formula(formula_str), data = ts_data)
  aic_values2[lag] <- AIC(model)
}

# Create a data frame to display AIC values
aic_results2 <- data.frame(UNRATE_Lags = unrate_lags, AIC = aic_values2)

# Print the AIC values for comparison
print(aic_results2) 

#Plot a graph to see which lag will give the lowest AIC
plot(aic_results2$UNRATE_Lags, aic_results2$AIC, type="b", pch=19, col="blue",
     xlab="Number of Lags for UNRATE", ylab="AIC", main="AIC for Different UNRATE Lags")

```

Choosing PCECC96
number of lags: 5
```{r}
# Define the range of lags for PCECC96
pcecc96_lags <- 1:10  

# Create an empty list to store AIC values
aic_values3 <- numeric(length(pcecc96_lags))

# Loop over different lag values for PCECC96
for (lag in pcecc96_lags) {
  # Construct the formula dynamically
  formula_str <- paste0("GDPC1 ~ ", 
                        paste0("L(GDPC1, ", 1:10, ")", collapse = " + "),  # Fixed lags for GDPC1
                        " + ", 
                        paste0("L(UNRATE, ", 1:2, ")", collapse = " + "),  # Fixed lags for UNRATE
                        " + ", 
                        paste0("L(PCECC96, ", 1:lag, ")", collapse = " + "))  # Varying lags for PCECC96
  model <- dynlm(as.formula(formula_str), data = ts_data)
  aic_values3[lag] <- AIC(model)
}

# Create a data frame to display AIC values
aic_results3 <- data.frame(PCECC96_Lags = pcecc96_lags, AIC = aic_values3)

# Print the AIC values for comparison
print(aic_results)

#Plot a graph to see which lag will give the lowest AIC
plot(aic_results3$PCECC96_Lags, aic_results3$AIC, type="b", pch=19, col="blue",
     xlab="Number of Lags for PCECC96", ylab="AIC", main="AIC for Different PCECC96 Lags")

```


### Final model
```{r}
final_model <- dynlm(GDPC1 ~ L(GDPC1, 1) + L(GDPC1, 2) + L(GDPC1, 3) + L(GDPC1, 4) + L(GDPC1, 5) + L(GDPC1, 6) + L(GDPC1, 7) + L(GDPC1, 8) +L(GDPC1, 9) +L(GDPC1, 10) + L(UNRATE, 1) + L(UNRATE, 2) + L(PCECC96, 1)+ L(PCECC96, 2)+ L(PCECC96, 3)+ L(PCECC96, 4)+ L(PCECC96, 5), data = ts_data)
```


Using arima to predict values for UNRATE
```{r}
data <- ts_data[,2]
model <- arima(data, order= c(1, 0,0))  # Simpler AR(1) model
summary(model)

value_UNRATE <- forecast(model, h=4)
print(value_UNRATE)
```


Using arima to predict values for PCECC96
```{r}
data2 <- ts_data[,3]
model2 <- auto.arima(data2)  # Simpler AR(1) model
summary(model2)

value_PEC <- forecast(model2, h=4)
print(value_PEC)

```


### Extracting the point forecasts values
```{r}
point_forecasts_pec <- value_PEC$mean
point_forecasts_values <- as.numeric(point_forecasts_pec)

point_forecasts_UNRATE <- value_UNRATE$mean
point_forecasts_values_ <- as.numeric(point_forecasts_UNRATE) 

# Create a new data frame and add the new point forecast values to ts_data
new_rows <- cbind(c(0,0,0,0),point_forecasts_values_, point_forecasts_values)

new_data_frame <- rbind(ts_data, new_rows)
```


# Forecasting
```{r}
#Forecast for 4 periods
forecast_values <- predict(final_model, n.ahead = 4, newdata=data.frame(new_data_frame))
print(forecast_values)

```